# -*- coding: utf-8 -*-

# Anki Add-on Builder
#
# Copyright (C)  2016-2021 Aristotelis P. <https://glutanimate.com/>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version, with the additions
# listed at the end of the license file that accompanied this program.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# NOTE: This program is subject to certain additional terms pursuant to
# Section 7 of the GNU Affero General Public License.  You should have
# received a copy of these additional terms immediately following the
# terms and conditions of the GNU Affero General Public License that
# accompanied this program.
#
# If not, please request a copy through one of the means of contact
# listed here: <https://glutanimate.com/contact/>.
#
# Any modifications to this file must keep this entire header intact.

"""
UI Compilation
"""

import logging
import re
import shutil
from datetime import datetime
from pathlib import Path
from typing import List, Optional

from whichcraft import which

from . import PATH_DIST, __title__, __version__
from .config import Config
from .legacy import QRCMigrator, QRCParser, QResourceDescriptor
from .utils import call_shell

QT_RESOURCES_FOLDER_NAME = "resources"
QT_DESIGNER_FOLDER_NAME = "designer"
FORMS_PACKAGE_NAME = "forms"
RESOURCES_PACKAGE_NAME = "resources"

_template_header = '''\
# -*- coding: utf-8 -*-
#
# {display_name} Add-on for Anki
# Copyright (C)  {years} {author}{contact}
#
# This file was automatically generated by {__title__} v{__version__}
# It is subject to the same licensing terms as the rest of the program
# (see the LICENSE file which accompanies this program).
#
# WARNING! All changes made in this file will be lost!

"""
Initializes generated Qt forms/resources
"""\
'''

_template_all = """\
__all__ = [
{}
]\
"""

_template_qt_shim = '''\
# -*- coding: utf-8 -*-
#
# {display_name} Add-on for Anki
# Copyright (C)  {years} {author}{contact}
#
# This file was automatically generated by {__title__} v{__version__}
# It is subject to the same licensing terms as the rest of the program
# (see the LICENSE file which accompanies this program).
#
# WARNING! All changes made in this file will be lost!

"""
Shim that imports forms corresponding to runtime Qt version
"""

from typing import TYPE_CHECKING

from aqt.qt import qtmajor

if TYPE_CHECKING or qtmajor >= 6:
    from .qt6 import *  # noqa: F401
else:
    from .qt5 import *  # noqa: F401
'''

from enum import Enum


class QtVersion(Enum):
    qt5 = 5
    qt6 = 6


class UIBuilder:

    _re_munge = re.compile(r"^import .+?_rc(\n)?$", re.MULTILINE)
    _ui_file_glob = "*.ui"
    _ui_file_tool = "pyuic"

    def __init__(self, root: Optional[Path] = None):
        self._root = root or PATH_DIST
        self._config = Config(path=self._root / "addon.json")

        self._gui_path: Path = self._root / "src" / self._config["module_name"] / "gui"
        self._resources_source_path = self._root / QT_RESOURCES_FOLDER_NAME
        self._resources_out_path = self._gui_path / RESOURCES_PACKAGE_NAME
        self._forms_source_path = self._root / QT_DESIGNER_FOLDER_NAME
        self._forms_out_path = self._gui_path / FORMS_PACKAGE_NAME

        self._format_dict = self._get_format_dict()

    def build(self, qt_version: QtVersion, pyenv=None):
        qt_version_key = qt_version.name

        logging.info("Starting UI build tasks for target %r...", qt_version_key)

        path_in = self._forms_source_path
        path_out = self._forms_out_path / qt_version_key

        if not path_in.exists():
            logging.warning(
                f"No Qt forms folder found under {self._forms_source_path}. Skipping"
                " build."
            )
            return

        if (
            self._resources_source_path.exists()
            and self._config.get("qt_resource_migration_mode") != "disabled"
        ):
            resource_prefixes_to_replace = self._migrate_resources()
        else:
            resource_prefixes_to_replace = []

        self._build(
            path_in=path_in,
            path_out=path_out,
            qt_version_number=qt_version.value,
            resource_prefixes_to_replace=resource_prefixes_to_replace,
            pyenv=pyenv,
        )

        logging.info("Done with all UI build tasks.")

    def create_qt_shim(self):
        # Qt shims are not needed as there are no qt files
        if not self._forms_out_path.is_dir():
            return

        out_path = self._forms_out_path / "__init__.py"
        if out_path.exists():
            out_path.unlink()
        format_dict = self._format_dict
        content = _template_qt_shim.format(**format_dict)
        with out_path.open("w", encoding="utf-8") as f:
            f.write(content)

    def _build(
        self,
        path_in: Path,
        path_out: Path,
        qt_version_number: int,
        resource_prefixes_to_replace: List[str],
        pyenv: Optional[str] = None,
    ):
        tool = self._ui_file_tool

        # Basic checks

        ui_files = list(path_in.glob(self._ui_file_glob))
        if not ui_files:
            logging.warning("No forms found in %s. Skipping %s build.", path_in, tool)
            return False

        tool = "{tool}{nr}".format(tool=tool, nr=qt_version_number)
        if which(tool) is None:
            logging.error(
                f"ERROR: {tool} not found. Please make sure PyQt{qt_version_number} is"
                " installed, or change the configuration to build the add-on for a"
                " different target Qt version.",
            )
            return False

        logging.info(
            "Building files in '%s' to '%s' with '%s'",
            self._rel_path(path_in),
            self._rel_path(path_out),
            tool,
        )

        # Cleanup

        logging.debug("Cleaning up old forms...")
        if path_out.exists():
            shutil.rmtree(str(path_out))
        path_out.mkdir(parents=True)

        # UI build loop

        modules = []

        env = "" if not pyenv else self._pyenv_prefix(pyenv)

        for in_file in ui_files:
            stem = in_file.stem
            out_file = Path(path_out / stem).with_suffix(".py")

            logging.debug("Building element '%s'...", stem)
            # Use relative paths to improve readability of form header:
            cmd = "{env} {tool} {in_file} -o {out_file}".format(
                env=env,
                tool=tool,
                in_file=self._rel_path(in_file),
                out_file=self._rel_path(out_file),
            )
            call_shell(cmd)

            self._munge_form(out_file, resource_prefixes_to_replace)

            modules.append(stem)

        # Last steps

        self._write_init_file(modules, path_out)

        logging.debug("Done with forms.")
        return True

    def _pyenv_prefix(self, pyenv):
        return (
            '''eval "$(pyenv init -)"'''
            '''&& eval "$(pyenv virtualenv-init -)"'''
            """&& pyenv activate {pyenv} > /dev/null 2>&1 &&""".format(pyenv=pyenv)
        )

    def _write_init_file(self, modules, path_out):
        logging.debug("Generating init file for %s", self._rel_path(path_out))

        header = _template_header.format(**self._format_dict)
        all_str = self._generate_all_str(modules)
        import_str = self._generate_import_str(modules)

        init = "\n\n".join((header, all_str, import_str)) + "\n"

        with (path_out / "__init__.py").open("w", encoding="utf-8") as f:
            f.write(init)

    def _generate_all_str(self, modules):
        module_string = ",\n".join('    "{}"'.format(m) for m in modules)
        out = _template_all.format(module_string)
        return out

    def _generate_import_str(self, modules):
        out = "\n".join("from . import {}".format(m) for m in modules)
        return out

    def _munge_form(self, path: Path, resource_prefixes_to_replace: List[str]):
        """
        Munge generated form to remove resource imports
        (I prefer to initialize these manually)
        """
        logging.debug("Munging %s...", self._rel_path(path))
        with path.open("r+", encoding="utf-8") as f:
            form = f.read()
            munged = self._re_munge.sub("", form)
            for prefix in resource_prefixes_to_replace:
                munged = form.replace(f'":/{prefix}/', f'"{prefix}:')
            f.seek(0)
            f.write(munged)
            f.truncate()

    def _migrate_resources(self) -> List[str]:
        """Returns list of prefixes to replace in built UI forms"""
        logging.info("Qt resources folder found. Attempting to migrate...")

        resources: List[QResourceDescriptor] = []

        for qrc_path in self._resources_source_path.glob("*.qrc"):
            parser = QRCParser(qrc_path=qrc_path)
            resources.extend(parser.get_qresources())

        if not resources:
            return []

        migrator = QRCMigrator(self._gui_path)
        integration_snippet = migrator.migrate_resources(resources=resources)

        content_init = (
            _template_header.format(**self._format_dict) + "\n" + integration_snippet
        )

        with (self._resources_out_path / "__init__.py").open(
            "w", encoding="utf-8"
        ) as f:
            f.write(content_init)

        prefixes = list(set(resource.prefix for resource in resources))

        return prefixes

    def _get_format_dict(self):
        config = self._config
        start_year = config.get("copyright_start")
        now = datetime.now().year
        if start_year and start_year != now:
            years = "{start_year}-{now}".format(start_year=start_year, now=now)
        else:
            years = "{now}".format(now=now)

        contact = config.get("contact")

        format_dict = {
            "display_name": config["display_name"],
            "author": config["author"],
            "contact": "" if not contact else " <{}>".format(contact),
            "__title__": __title__,
            "__version__": __version__,
            "years": years,
        }

        return format_dict

    def _rel_path(self, path: Path):
        return path.relative_to(self._root)
